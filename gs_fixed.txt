/**
 * Just Vitality Clinic - Backend v10.3 (Queue Bug Fixed)
 * CHANGELOG v10.3:
 * - FIXED: Patient now correctly appears in queue after kiosk registration
 * - Daily_Queue now has 7 columns: Timestamp, PatientID, FirstName, LastName, Status, Reason, Alerts
 * - processRegistration writes "WAITING" to Status column
 * - getDashboardData correctly reads Status and Reason from separate columns
 */

const SESSION_TTL = 21600; 
const SALT_LENGTH = 16;
const MAX_LOGIN_ATTEMPTS = 5;
const RATE_WINDOW_SECONDS = 86400; // 24h

function doGet(e) {
  _initAllSheets();
  return HtmlService.createHtmlOutputFromFile('staff')
    .setTitle('Just Vitality Clinic')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0');
}

// ==========================================
// 1. AUTHENTICATION
// ==========================================

function loginUser(username, password) {
  const cache = CacheService.getScriptCache();
  const cleanUser = String(username || "").trim().toUpperCase();

  const sheet = _getOrInitSheet("Users");
  const data = sheet.getDataRange().getValues();
  let userRow = null;
  let rowIndex = -1;

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]).toUpperCase() === cleanUser) {
      userRow = data[i];
      rowIndex = i + 1;
      break;
    }
  }

  if (!userRow) {
    const count = _incrementRateLimit(cleanUser);
    _logLoginEvent(cleanUser, "FAIL", `User not found (count=${count})`);
    return { success: false, error: "Invalid credentials." };
  }

  const storedHash = userRow[1];
  const salt = userRow[2];
  const role = userRow[3];
  const isActive = userRow[4];

  if (!isActive) {
    _logLoginEvent(cleanUser, "LOCKED", "Account inactive");
    return { success: false, error: "Account locked. Please contact admin." };
  }

  if (_hash(password, salt) !== storedHash) {
    const count = _incrementRateLimit(cleanUser);
    _logLoginEvent(cleanUser, "FAIL", `Wrong password (count=${count})`);

    if (count >= MAX_LOGIN_ATTEMPTS) {
      sheet.getRange(rowIndex, 5).setValue(false);
      _logLoginEvent(cleanUser, "LOCKOUT", "Reached max failed attempts - Active set to FALSE");
      return { success: false, error: "Too many failed attempts. This account has been locked. Contact admin." };
    }
    return { success: false, error: "Invalid credentials." };
  }

  _clearRateLimit(cleanUser);

  const token = Utilities.getUuid();
  cache.put("session_" + token, JSON.stringify({ user: cleanUser, role: role }), SESSION_TTL);
  
  sheet.getRange(rowIndex, 6).setValue(new Date()); 

  _logLoginEvent(cleanUser, "SUCCESS", "Logged in");
  return { success: true, token: token, username: cleanUser, role: role };
}

function changePassword(token, currentPass, newPass) {
  const session = _verifySession(token);
  if (!session) return { success: false, error: "Session expired." };
  if (newPass.length < 5) return { success: false, error: "Password too short." };

  const sheet = _getOrInitSheet("Users");
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]).toUpperCase() === session.user) {
      const oldHash = data[i][1];
      const oldSalt = data[i][2];
      
      if (_hash(currentPass, oldSalt) !== oldHash) {
        return { success: false, error: "Current password incorrect." };
      }

      const newSalt = _generateSalt();
      const newHash = _hash(newPass, newSalt);
      
      sheet.getRange(i + 1, 2).setValue(newHash);
      sheet.getRange(i + 1, 3).setValue(newSalt);
      return { success: true };
    }
  }
  return { success: false, error: "User not found." };
}

// ==========================================
// 2. ADMIN & MANAGER MANAGEMENT
// ==========================================

function adminGetUsers(token) {
  const session = _verifySession(token);
  if (!session || (session.role !== "ADMIN" && session.role !== "MANAGER")) {
    return { success: false, error: "Access Denied" };
  }
  
  const sheet = _getOrInitSheet("Users");
  const data = sheet.getDataRange().getValues();
  const users = [];
  
  for (let i = 1; i < data.length; i++) {
    users.push({
      username: String(data[i][0]).toUpperCase(),
      role: data[i][3],
      active: data[i][4],
      lastLogin: _formatDate(data[i][5], true)
    });
  }
  return { success: true, users: users };
}

function adminAddUser(token, newUser, newPass, role) {
  if (!_isAdmin(token)) return { success: false, error: "Access Denied. Only Admin can add users." };
  
  if (!newUser || !newPass) return { success: false, error: "Missing fields" };
  
  const userUpper = newUser.trim().toUpperCase();
  const sheet = _getOrInitSheet("Users");
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]).toUpperCase() === userUpper) {
      return { success: false, error: "User already exists" };
    }
  }
  
  const salt = _generateSalt();
  const hash = _hash(newPass, salt);
  
  sheet.appendRow([userUpper, hash, salt, role || "STAFF", true, ""]);
  return { success: true };
}

function adminResetPassword(token, targetUser, tempPass) {
  const session = _verifySession(token);
  if (!session || (session.role !== "ADMIN" && session.role !== "MANAGER")) {
    return { success: false, error: "Access Denied" };
  }
  
  const targetUpper = targetUser.trim().toUpperCase();
  const sheet = _getOrInitSheet("Users");
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]).toUpperCase() === targetUpper) {
      const targetRole = String(data[i][3]); 
      if (session.role === "MANAGER" && targetRole === "ADMIN") {
        return { success: false, error: "Managers cannot reset Admin passwords." };
      }

      const salt = _generateSalt();
      const hash = _hash(tempPass, salt);
      
      sheet.getRange(i + 1, 2).setValue(hash);
      sheet.getRange(i + 1, 3).setValue(salt);
      sheet.getRange(i + 1, 5).setValue(true);
      _clearRateLimit(targetUpper);
      _logLoginEvent(targetUpper, "ADMIN_RESET", `Password reset by ${session.user}; Active=TRUE`);
      return { success: true };
    }
  }
  return { success: false, error: "User not found" };
}

function adminSetUserActive(token, targetUser, active) {
  const session = _verifySession(token);
  if (!session || (session.role !== "ADMIN" && session.role !== "MANAGER")) {
    return { success: false, error: "Access Denied" };
  }

  const targetUpper = String(targetUser || "").trim().toUpperCase();
  if (!targetUpper) return { success: false, error: "Missing username" };

  const sheet = _getOrInitSheet("Users");
  const data = sheet.getDataRange().getValues();

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]).toUpperCase() === targetUpper) {
      const targetRole = String(data[i][3]);
      if (session.role === "MANAGER" && targetRole === "ADMIN") {
        return { success: false, error: "Managers cannot change Admin status." };
      }

      sheet.getRange(i + 1, 5).setValue(!!active);
      _clearRateLimit(targetUpper);
      _logLoginEvent(targetUpper, "ADMIN_ACTIVE", `Active set to ${!!active} by ${session.user}`);
      return { success: true };
    }
  }
  return { success: false, error: "User not found" };
}

function adminGetLoginAudit(token, limit) {
  if (!_isAdmin(token)) return { success: false, error: "Access Denied" };
  const sheet = _getOrInitSheet("Login_Audit");
  const data = sheet.getDataRange().getValues();
  const n = Math.max(1, Math.min(parseInt(limit || 200, 10), 2000));
  const rows = data.slice(1).slice(-n).reverse().map(r => ({
    ts: _formatDate(r[0], true),
    username: String(r[1] || ""),
    event: String(r[2] || ""),
    details: String(r[3] || "")
  }));
  return { success: true, rows: rows };
}

function adminClearLoginAudit(token) {
  if (!_isAdmin(token)) return { success: false, error: "Access Denied" };
  const sheet = _getOrInitSheet("Login_Audit");
  if (sheet.getLastRow() > 1) {
    sheet.deleteRows(2, sheet.getLastRow() - 1);
  }
  _logLoginEvent("SYSTEM", "ADMIN_CLEAR", "Login_Audit cleared");
  return { success: true };
}

// ==========================================
// 3. DASHBOARD & DATA
// ==========================================

function getDashboardData(token) {
  if (!_verifySession(token)) return { success: false, error: "Unauthorized" };

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetMaster = ss.getSheetByName("Patients_Master");
    const sheetQueue = ss.getSheetByName("Daily_Queue");
    const sheetVisits = ss.getSheetByName("Visits_Log");
    
    // 0. NEW PATIENT LOGIC: Get set of all patients who have visits
    const visitedIds = new Set();
    if (sheetVisits) {
       const vData = sheetVisits.getDataRange().getValues();
       if (vData.length > 1) {
         vData.slice(1).forEach(r => visitedIds.add(String(r[1])));
       }
    }

    // 1. ALERTS & QUEUE (Read from Daily_Queue)
    // FIXED: Now correctly reading columns:
    // [0]=Timestamp, [1]=PatientID, [2]=FirstName, [3]=LastName, [4]=Status, [5]=Reason, [6]=Alerts
    const alertsMap = {};
    const activeVisitsMap = {};  // Maps patientId -> reason
    const queueList = [];

    if (sheetQueue) {
       const data = sheetQueue.getDataRange().getValues();
       if(data.length > 1) {
         const today = _formatDate(new Date(), false);
         data.slice(1).forEach(r => {
           if(_formatDate(r[0], false) === today) {
             const pid = String(r[1]);
             const status = String(r[4] || "").trim().toUpperCase();
             const reason = String(r[5] || "").trim();  // FIXED: Reason is now column 5 (index 5)
             const alertText = String(r[6] || "").trim();  // FIXED: Alerts is now column 6 (index 6)
             
             // Only include if status is not DONE
             if (status !== "DONE") {
                activeVisitsMap[pid] = reason;
             }
             if (alertText) {
                alertsMap[pid] = alertText;
             }
           }
         });
       }
    }

    // 2. Patients Master Data
    const dataMaster = sheetMaster.getDataRange().getValues();
    let patients = [];
    if (dataMaster.length > 1) {
      dataMaster.slice(1).forEach(r => {
        if(r[0]) {
           const pid = String(r[0]);
           const activeReason = activeVisitsMap[pid] || null;
           
           const pObj = {
             id: pid,
             name: String(r[1]||"") + " " + String(r[2]||""),
             firstName: String(r[1]||""), lastName: String(r[2]||""), dob: _formatDate(r[3]),
             street: String(r[4]||""), city: String(r[5]||""), postcode: String(r[6]||""),
             phone: String(r[7]||""), email: String(r[8]||""),
             reason: String(r[9]||""), 
             meds: String(r[10]||""), 
             allergies: String(r[11]||""),
             conditions: String(r[12]||""), 
             procedures: String(r[13]||""), 
             surgeries: String(r[14]||""), 
             emergencyName: String(r[16]||""), emergencyPhone: String(r[17]||""),
             alerts: alertsMap[pid] || null, 
             queueReason: activeReason,
             isNew: !visitedIds.has(pid)
           };
           patients.push(pObj);
           if(activeReason) queueList.push(pObj);
        }
      });
    }
    patients.sort((a, b) => a.lastName.localeCompare(b.lastName));
    return { success: true, all: patients, queue: queueList };

  } catch (e) { return { success: false, error: e.message }; }
}

function processRegistration(form, token) {
  let user = "KIOSK";
  let skipQueue = false;

  if (token) {
    const session = _verifySession(token);
    if (session) {
      user = session.user;
      if (form.skipQueue) skipQueue = true;
    } else if (form.skipQueue) {
      return { success: false, error: "Unauthorized" };
    }
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const masterSheet = _getOrInitSheet("Patients_Master");
  const auditSheet = _getOrInitSheet("System_Audit_Log");
  const queueSheet = _getOrInitSheet("Daily_Queue");

  const id = form.id;
  const now = new Date();
  
  const data = masterSheet.getDataRange().getValues();
  let rowIndex = -1;
  let currentVals = [];

  for (let i=1; i<data.length; i++) {
    if (String(data[i][0]) === id) {
      rowIndex = i + 1;
      currentVals = data[i];
      break;
    }
  }

  const updates = [
     { idx: 4, val: form.street, name: "Street" }, { idx: 5, val: form.city, name: "City" },
     { idx: 6, val: form.postcode, name: "Postcode" }, { idx: 7, val: form.phone, name: "Phone" },
     { idx: 8, val: form.email, name: "Email" }, 
     { idx: 10, val: form.meds, name: "Medications" },       
     { idx: 11, val: form.allergies, name: "Allergies" },    
     { idx: 12, val: form.conditions, name: "Conditions" },  
     { idx: 13, val: form.procedures, name: "Procedures/IV History" }, 
     { idx: 14, val: form.surgeries, name: "Surgeries" },    
     { idx: 16, val: form.emergencyName, name: "EmergencyName" }, { idx: 17, val: form.emergencyPhone, name: "EmergencyPhone" }
  ];

  if (rowIndex > 0) {
    updates.forEach(u => {
      const oldVal = String(currentVals[u.idx] || "").trim();
      const newVal = String(u.val || "").trim();
      if (oldVal !== newVal) {
        while (currentVals.length <= u.idx) currentVals.push(""); 
        currentVals[u.idx] = newVal;
        if(auditSheet) auditSheet.appendRow([now, id, u.name, oldVal, newVal, user]);
      }
    });
    masterSheet.getRange(rowIndex, 1, 1, currentVals.length).setValues([currentVals]);
  } else {
    const newRow = [
      id, form.firstName, form.lastName, form.dob, form.street, form.city, form.postcode,
      form.phone, form.email, "", 
      form.meds, 
      form.allergies, 
      form.conditions, 
      form.procedures, 
      form.surgeries,  
      _formatDate(now, true), form.emergencyName, form.emergencyPhone
    ];
    masterSheet.appendRow(newRow);
    if(auditSheet) auditSheet.appendRow([now, id, "REGISTER", "New Patient", "", user]);
  }

  // FIXED: Add to queue with correct column order
  // Columns: Timestamp, PatientID, FirstName, LastName, Status, Reason, Alerts
  if (queueSheet && !skipQueue) {
    queueSheet.appendRow([
        _formatDate(now, true),   // Timestamp
        id,                        // PatientID
        form.firstName,            // FirstName
        form.lastName,             // LastName
        "WAITING",                 // Status <-- FIXED: Now explicitly "WAITING"
        form.reason,               // Reason <-- FIXED: Moved to column 6
        form.alerts                // Alerts <-- FIXED: Moved to column 7
    ]);
  }
  return { success: true };
}

function updatePatientFull(form, token) {
  if (!_verifySession(token)) return { success: false, error: "Unauthorized" };

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const masterSheet = ss.getSheetByName("Patients_Master");
  const auditSheet = ss.getSheetByName("System_Audit_Log");
  const id = form.id;

  const data = masterSheet.getDataRange().getValues();
  const session = _verifySession(token);
  const user = session ? session.user : "SYSTEM";
  const now = new Date();

  for (let i=1; i<data.length; i++) {
    if (String(data[i][0]) === id) {
      const row = i + 1;
      const updates = [
        { col: 5, val: form.street, name: "Street" }, { col: 6, val: form.city, name: "City" },
        { col: 7, val: form.postcode, name: "Postcode" }, { col: 8, val: form.phone, name: "Phone" },
        { col: 9, val: form.email, name: "Email" },
        { col: 11, val: form.meds, name: "Medications" },
        { col: 12, val: form.allergies, name: "Allergies" },
        { col: 13, val: form.conditions, name: "Conditions" },
        { col: 14, val: form.procedures, name: "Procedures/IV History" },
        { col: 15, val: form.surgeries, name: "Surgeries" },
        { col: 17, val: form.emergencyName, name: "EmergencyName" },
        { col: 18, val: form.emergencyPhone, name: "EmergencyPhone" }
      ];

      updates.forEach(u => {
        const oldVal = String(data[i][u.col - 1] || "").trim();
        const newVal = String(u.val || "").trim();
        if (oldVal !== newVal) {
          masterSheet.getRange(row, u.col).setValue(newVal);
          if(auditSheet) auditSheet.appendRow([now, id, u.name, oldVal, newVal, user]);
        }
      });

      return { success: true };
    }
  }
  return { success: false, error: "Patient not found" };
}

function saveNewVisit(data, token) {
  const session = _verifySession(token);
  if (!session) return { success: false, error: "Unauthorized" };

  const visitSheet = _getOrInitSheet("Visits_Log");
  const queueSheet = _getOrInitSheet("Daily_Queue");

  visitSheet.appendRow([Utilities.getUuid(), data.patientId, _formatDate(new Date(), true), data.treatment, data.notes, session.user]);

  // FIXED: Mark queue entry as DONE (column 5 is Status)
  if (queueSheet) {
    const qData = queueSheet.getDataRange().getValues();
    const today = _formatDate(new Date(), false);
    for (let i = qData.length - 1; i >= 1; i--) {
      if (String(qData[i][1]) === data.patientId && _formatDate(qData[i][0], false) === today && String(qData[i][4]).toUpperCase() !== "DONE") {
        queueSheet.getRange(i + 1, 5).setValue("DONE");  // Column 5 = Status
        break;
      }
    }
  }
  return { success: true };
}

function getVisitsHistory(pid, token) {
  if (!_verifySession(token)) return [];
  const sheet = _getOrInitSheet("Visits_Log");
  const data = sheet.getDataRange().getValues();
  if(data.length < 2) return [];
  return data.slice(1)
    .filter(r => String(r[1]) === String(pid))
    .map(r => ({ date: _formatDate(r[2], true), treatment: r[3], notes: r[4], consultant: r[5] }))
    .sort((a,b) => new Date(b.date) - new Date(a.date));
}

function getPatientAudit(pid, token) {
  if (!_verifySession(token)) return [];
  const sheet = _getOrInitSheet("System_Audit_Log");
  const data = sheet.getDataRange().getValues();
  const logs = [];
  if (data.length > 1) {
    const rows = data.slice(1).sort((a,b) => new Date(b[0]) - new Date(a[0]));
    rows.forEach(r => {
      if (String(r[1]) === String(pid)) {
        logs.push({
          date: _formatDate(r[0], true), field: String(r[2]), oldVal: String(r[3]), newVal: String(r[4]), user: String(r[5])
        });
      }
    });
  }
  return logs;
}

// ==========================================
// 4. REPORT ANALYTICS
// ==========================================

function getReportData(token, startDate, endDate) {
  if (!_verifySession(token)) return { success: false, error: "Unauthorized" };

  const start = new Date(startDate); start.setHours(0,0,0,0);
  const end = new Date(endDate); end.setHours(23,59,59,999);
  
  if (isNaN(start.getTime()) || isNaN(end.getTime())) return { success: false, error: "Invalid Dates" };

  const diffTime = Math.abs(end - start);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
  const isMonthly = diffDays > 8; 

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const visitsSheet = ss.getSheetByName("Visits_Log");
  const masterSheet = ss.getSheetByName("Patients_Master");
  
  const visits = [];
  const patientsInfo = {}; 
  
  let newPatientCount = 0;
  if (masterSheet) {
    const mData = masterSheet.getDataRange().getValues();
    if (mData.length > 1) {
      mData.slice(1).forEach(r => {
        const regDate = new Date(r[15]); 
        if (regDate >= start && regDate <= end) newPatientCount++;
        const pid = String(r[0]);
        const name = String(r[1] || "") + " " + String(r[2] || ""); 
        const city = String(r[5] || "Unknown").trim();
        patientsInfo[pid] = { name: name, city: city };
      });
    }
  }

  if (visitsSheet) {
    const vData = visitsSheet.getDataRange().getValues();
    if (vData.length > 1) {
      vData.slice(1).forEach(r => {
        const vDate = new Date(r[2]); 
        if (vDate >= start && vDate <= end) {
          const pid = String(r[1]);
          visits.push({
            date: vDate,
            pid: pid,
            patientName: patientsInfo[pid] ? patientsInfo[pid].name : "Unknown",
            city: patientsInfo[pid] ? patientsInfo[pid].city : "Unknown",
            treatment: String(r[3] || ""),
            notes: String(r[4] || ""),
            consultant: String(r[5] || "Unknown")
          });
        }
      });
    }
  }

  const uniquePatientsSet = new Set(visits.map(v => v.pid));
  const uniquePatientCount = uniquePatientsSet.size;

  const consultantCount = {};
  visits.forEach(v => { consultantCount[v.consultant] = (consultantCount[v.consultant] || 0) + 1; });

  const dayCount = {};
  const hourCount = {}; 
  visits.forEach(v => {
    const dayKey = isMonthly 
      ? `${v.date.getFullYear()}-${String(v.date.getMonth() + 1).padStart(2, '0')}`
      : _formatDate(v.date, false);
    dayCount[dayKey] = (dayCount[dayKey] || 0) + 1;
    
    const dayOfWeek = v.date.getDay(); 
    const hour = v.date.getHours();
    const heatKey = `${dayOfWeek}-${hour}`;
    hourCount[heatKey] = (hourCount[heatKey] || 0) + 1;
  });

  return {
    success: true,
    summary: {
      totalVisits: visits.length,
      uniquePatients: uniquePatientCount,
      newPatients: newPatientCount,
      avgVisitsPerDay: diffDays > 0 ? (visits.length / diffDays).toFixed(1) : visits.length
    },
    consultantStats: Object.entries(consultantCount).map(([name, count]) => ({ name, count })).sort((a,b) => b.count - a.count),
    dailyStats: Object.entries(dayCount).map(([date, count]) => ({ date, count })).sort((a,b) => a.date.localeCompare(b.date)),
    hourlyHeatmap: hourCount, 
    visitsList: visits.map(v => ({
      date: _formatDate(v.date, true),
      patientName: v.patientName,
      city: v.city,
      treatment: v.treatment,
      consultant: v.consultant
    }))
  };
}

// ==========================================
// 5. MANAGER ZONE (Delete, Export)
// ==========================================

function deletePatientRecord(patientId, password, token) {
  const session = _verifySession(token);
  if (!session || (session.role !== "ADMIN" && session.role !== "MANAGER")) {
    return { success: false, error: "Unauthorized. Manager or Admin only." };
  }

  const sheet = _getOrInitSheet("Users");
  const data = sheet.getDataRange().getValues();
  let verified = false;
  for (let i=1; i<data.length; i++) {
    if (String(data[i][0]).toUpperCase() === session.user) {
      if (_hash(password, data[i][2]) === data[i][1]) {
        verified = true;
      }
      break;
    }
  }
  if (!verified) return { success: false, error: "Invalid Password." };

  const mSheet = _getOrInitSheet("Patients_Master");
  const mData = mSheet.getDataRange().getValues();
  let deleted = false;

  for (let i = mData.length - 1; i >= 1; i--) {
    if (String(mData[i][0]) === String(patientId)) {
      mSheet.deleteRow(i + 1);
      deleted = true;
      break;
    }
  }

  if (!deleted) return { success: false, error: "Patient not found." };

  const vSheet = _getOrInitSheet("Visits_Log");
  const vData = vSheet.getDataRange().getValues();
  for (let i = vData.length - 1; i >= 1; i--) {
    if (String(vData[i][1]) === String(patientId)) {
      vSheet.deleteRow(i + 1);
    }
  }

  const auditSheet = _getOrInitSheet("System_Audit_Log");
  if(auditSheet) auditSheet.appendRow([new Date(), patientId, "DELETE", "Full Record", "DELETED", session.user]);

  return { success: true };
}

function getPatientPdfBase64(patientId, token) {
  if (!_verifySession(token)) return { success: false, error: "Unauthorized" };

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const mData = ss.getSheetByName("Patients_Master").getDataRange().getValues();
  const vData = ss.getSheetByName("Visits_Log").getDataRange().getValues();

  let p = null;
  for(let i=1; i<mData.length; i++) {
    if(String(mData[i][0]) === String(patientId)) {
      p = mData[i]; break;
    }
  }
  if(!p) return { success: false, error: "Patient not found" };

  const history = vData.slice(1).filter(r => String(r[1]) === String(patientId))
                  .map(r => `<tr><td>${_formatDate(r[2], true)}</td><td>${r[3]}</td><td>${r[4]}</td><td>${r[5]}</td></tr>`)
                  .join("");

  const html = `
    <html>
      <head>
        <style>
          body { font-family: sans-serif; padding: 20px; color: #333; }
          h1 { color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 10px; }
          h2 { background: #f3f4f6; padding: 5px; margin-top: 20px; font-size: 14px; border-left: 4px solid #2563eb; }
          .grid { display: table; width: 100%; margin-bottom: 10px; }
          .row { display: table-row; }
          .cell { display: table-cell; padding: 4px; width: 50%; font-size: 12px; border-bottom: 1px solid #eee; }
          .label { font-weight: bold; color: #666; width: 30%; }
          table { width: 100%; border-collapse: collapse; font-size: 11px; margin-top: 10px; }
          th { text-align: left; background: #eee; padding: 5px; border-bottom: 1px solid #ccc; }
          td { padding: 5px; border-bottom: 1px solid #eee; }
          .footer { margin-top: 30px; font-size: 10px; color: #999; text-align: center; }
        </style>
      </head>
      <body>
        <h1>Patient Record Export</h1>
        <div class="grid">
          <div class="row"><div class="cell label">ID:</div><div class="cell">${p[0]}</div></div>
          <div class="row"><div class="cell label">Name:</div><div class="cell"><b>${p[1]} ${p[2]}</b></div></div>
          <div class="row"><div class="cell label">DOB:</div><div class="cell">${_formatDate(p[3])}</div></div>
          <div class="row"><div class="cell label">Registered:</div><div class="cell">${_formatDate(p[15], true)}</div></div>
        </div>

        <h2>Contact Information</h2>
        <div class="grid">
          <div class="row"><div class="cell label">Phone:</div><div class="cell">${p[7]}</div></div>
          <div class="row"><div class="cell label">Email:</div><div class="cell">${p[8]}</div></div>
          <div class="row"><div class="cell label">Address:</div><div class="cell">${p[4]}, ${p[5]} ${p[6]}</div></div>
          <div class="row"><div class="cell label">Emergency:</div><div class="cell">${p[16]} (${p[17]})</div></div>
        </div>

        <h2>Medical Profile</h2>
        <div class="grid">
           <div class="row"><div class="cell label">Conditions:</div><div class="cell">${p[12]}</div></div>
           <div class="row"><div class="cell label">Allergies:</div><div class="cell" style="color:red">${p[11]}</div></div>
           <div class="row"><div class="cell label">Meds:</div><div class="cell">${p[10]}</div></div>
           <div class="row"><div class="cell label">Surgeries:</div><div class="cell">${p[14]}</div></div>
           <div class="row"><div class="cell label">IV/Notes:</div><div class="cell">${p[13]}</div></div>
        </div>

        <h2>Visit History</h2>
        <table>
          <thead><tr><th>Date</th><th>Treatment</th><th>Notes</th><th>Consultant</th></tr></thead>
          <tbody>${history || "<tr><td colspan='4'>No visits recorded.</td></tr>"}</tbody>
        </table>

        <div class="footer">Generated by Just Vitality System v10.3 on ${new Date().toLocaleString()}</div>
      </body>
    </html>
  `;

  const blob = Utilities.newBlob(html, MimeType.HTML).getAs(MimeType.PDF);
  return { success: true, data: Utilities.base64Encode(blob.getBytes()) };
}

// ---------------------------------------------
// HELPER FUNCTIONS
// ---------------------------------------------

function checkPatientExists(first, last, dob, postcode) {
  try {
    const id = _generateID(first, last, dob);
    const sheet = _getOrInitSheet("Patients_Master");
    const data = sheet.getDataRange().getValues();

    let status = 'NOT_FOUND';
    let found = null;

    if(data.length > 1) {
      for (let i=1; i<data.length; i++) {
        if (String(data[i][0]) === id) {
          const dbPostcode = String(data[i][6] || "").replace(/\s+/g, '').toUpperCase();
          const inPostcode = String(postcode || "").replace(/\s+/g, '').toUpperCase();

          if (dbPostcode === inPostcode) {
             const r = data[i];
             status = 'SUCCESS';
             found = {
               id: String(r[0]), firstName: String(r[1]), lastName: String(r[2]), dob: _formatDate(r[3]),
               street: String(r[4]), city: String(r[5]), postcode: String(r[6]), phone: String(r[7]), email: String(r[8]),
               meds: String(r[10]), allergies: String(r[11]), conditions: String(r[12]), procedures: String(r[13]), surgeries: String(r[14]),
               emergencyName: String(r[16]||""), emergencyPhone: String(r[17]||"")
             };
          } else {
             status = 'PARTIAL_MATCH';
          }
          break;
        }
      }
    }
    return { status: status, id: id, data: found };
  } catch (e) {
    return { error: e.message, status: 'ERROR', id: null };
  }
}

function _initAllSheets() {
  _getOrInitSheet("Users", ["Username", "PasswordHash", "Salt", "Role", "Active", "LastLogin"]);
  _getOrInitSheet("Patients_Master", ["PatientID","FirstName","LastName","DOB","Street","City","Postcode","Phone","Email","Reason","Medications","Allergies","Conditions","Procedures","Surgeries","RegistrationDate","EmergencyName","EmergencyPhone"]);
  _getOrInitSheet("Visits_Log", ["VisitID","PatientID","VisitDate","Treatment","Notes","Consultant"]);
  
  // FIXED: Daily_Queue now has 7 columns with separate Status and Reason
  _getOrInitSheet("Daily_Queue", ["Timestamp","PatientID","FirstName","LastName","Status","Reason","Alerts"]);
  
  _getOrInitSheet("System_Audit_Log", ["Timestamp","PatientID","Action","OldValue","NewValue","User"]);
  _getOrInitSheet("Login_Audit", ["Timestamp","Username","Event","Details"]);
  
  const uSheet = _getOrInitSheet("Users");
  if(uSheet.getLastRow() === 1) {
     const salt = _generateSalt();
     const hash = _hash("vit2025", salt);
     uSheet.appendRow(["ADMIN", hash, salt, "ADMIN", true, new Date()]);
  }
}

function _getOrInitSheet(name, headers) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(name);
  if (!sheet) {
    sheet = ss.insertSheet(name);
    if(headers) sheet.appendRow(headers);
  }
  return sheet;
}

function _verifySession(token) {
  if (!token) return null;
  const cache = CacheService.getScriptCache();
  const cached = cache.get("session_" + token);
  return cached ? JSON.parse(cached) : null;
}

function _isAdmin(token) {
  const session = _verifySession(token);
  return (session && session.role === "ADMIN");
}

function _incrementRateLimit(username) {
  const cache = CacheService.getScriptCache();
  const key = "rate_" + username;
  let count = parseInt(cache.get(key) || "0", 10);
  count++;
  cache.put(key, String(count), RATE_WINDOW_SECONDS);
  return count;
}

function _clearRateLimit(username) {
  const cache = CacheService.getScriptCache();
  cache.remove("rate_" + username);
}

function _logLoginEvent(username, event, details) {
  try {
    const sheet = _getOrInitSheet("Login_Audit");
    sheet.appendRow([new Date(), String(username || ""), String(event || ""), String(details || "")]);
  } catch (e) {
    // Do not break auth flow if logging fails
  }
}

function logSessionEnd(token) {
  const session = _verifySession(token);
  const cache = CacheService.getScriptCache();
  if (token) cache.remove("session_" + token);
  if (session) _logLoginEvent(session.user, "LOGOUT", "Session ended");
  return { success: true };
}

function _hash(input, salt) {
  const raw = input + salt;
  const digest = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, raw);
  return Utilities.base64Encode(digest);
}

function _generateSalt() {
  return Utilities.getUuid().substring(0, SALT_LENGTH);
}

function _generateID(first, last, dob) {
  const normalize = (str) => {
    return (str || "").trim()
      .normalize("NFD").replace(/[\u0300-\u036f]/g, "") 
      .replace(/ł/g, "l").replace(/Ł/g, "L") 
      .toUpperCase()
      .replace(/[^A-Z0-9]/g, ""); 
  };
  return `${normalize(last)}-${normalize(first)}-${dob}`;
}

function _formatDate(dateObj, includeTime) {
  if (!dateObj) return "";
  const d = new Date(dateObj);
  if (isNaN(d.getTime())) return String(dateObj);
  let str = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  if (includeTime) str += ` ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
  return str;
}
